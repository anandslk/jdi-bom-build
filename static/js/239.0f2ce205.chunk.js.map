{"version":3,"file":"static/js/239.0f2ce205.chunk.js","mappings":"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","sources":["../node_modules/@tanstack/query-core/src/focusManager.ts","../node_modules/@tanstack/query-core/src/notifyManager.ts","../node_modules/@tanstack/query-core/src/onlineManager.ts","../node_modules/@tanstack/query-core/src/query.ts","../node_modules/@tanstack/query-core/src/removable.ts","../node_modules/@tanstack/query-core/src/retryer.ts","../node_modules/@tanstack/query-core/src/subscribable.ts","../node_modules/@tanstack/query-core/src/thenable.ts","../node_modules/@tanstack/query-core/src/utils.ts","../node_modules/@tanstack/react-query/src/QueryClientProvider.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/checkPrivateRedeclaration.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js"],"sourcesContent":["import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (focused: boolean) => void\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable<Listener> {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.#focused !== focused\n    if (changed) {\n      this.#focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    const isFocused = this.isFocused()\n    this.listeners.forEach((listener) => {\n      listener(isFocused)\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n","// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\ntype ScheduleFunction = (callback: () => void) => void\n\nexport const defaultScheduler: ScheduleFunction = (cb) => setTimeout(cb, 0)\n\nexport function createNotifyManager() {\n  let queue: Array<NotifyCallback> = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n  let scheduleFn = defaultScheduler\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  return {\n    batch: <T>(callback: () => T): T => {\n      let result\n      transactions++\n      try {\n        result = callback()\n      } finally {\n        transactions--\n        if (!transactions) {\n          flush()\n        }\n      }\n      return result\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: <T extends Array<unknown>>(\n      callback: BatchCallsCallback<T>,\n    ): BatchCallsCallback<T> => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args)\n        })\n      }\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn: NotifyFunction) => {\n      notifyFn = fn\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn: BatchNotifyFunction) => {\n      batchNotifyFn = fn\n    },\n    setScheduler: (fn: ScheduleFunction) => {\n      scheduleFn = fn\n    },\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (online: boolean) => void\ntype SetupFn = (setOnline: Listener) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable<Listener> {\n  #online = true\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true)\n        const offlineListener = () => onOnline(false)\n        // Listen to online\n        window.addEventListener('online', onlineListener, false)\n        window.addEventListener('offline', offlineListener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onlineListener)\n          window.removeEventListener('offline', offlineListener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup(this.setOnline.bind(this))\n  }\n\n  setOnline(online: boolean): void {\n    const changed = this.#online !== online\n\n    if (changed) {\n      this.#online = online\n      this.listeners.forEach((listener) => {\n        listener(online)\n      })\n    }\n  }\n\n  isOnline(): boolean {\n    return this.#online\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunction,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStale(): boolean {\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.data === undefined ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const queryFnContext: OmitKeyof<\n        QueryFunctionContext<TQueryKey>,\n        'signal'\n      > = {\n        client: this.#client,\n        queryKey: this.queryKey,\n        meta: this.meta,\n      }\n\n      addSignalProperty(queryFnContext)\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn as QueryFunction<any>,\n          queryFnContext as QueryFunctionContext<TQueryKey>,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext as QueryFunctionContext<TQueryKey>)\n    }\n\n    // Trigger behavior hook\n    const context: OmitKeyof<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      client: this.#client,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      this as unknown as Query,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n","import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  gcTime!: number\n  #gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.gcTime)\n    }\n  }\n\n  protected updateGcTime(newGcTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout)\n      this.#gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { pendingThenable } from './thenable'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n\n  const thenable = pendingThenable<TData>()\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      thenable.resolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      thenable.reject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return thenable\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return thenable\n    },\n  }\n}\n","export class Subscribable<TListener extends Function> {\n  protected listeners = new Set<TListener>()\n\n  constructor() {\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","/**\n * Thenable types which matches React's types for promises\n *\n * React seemingly uses `.status`, `.value` and `.reason` properties on a promises to optimistically unwrap data from promises\n *\n * @see https://github.com/facebook/react/blob/main/packages/shared/ReactTypes.js#L112-L138\n * @see https://github.com/facebook/react/blob/4f604941569d2e8947ce1460a0b2997e835f37b9/packages/react-debug-tools/src/ReactDebugHooks.js#L224-L227\n */\n\ninterface Fulfilled<T> {\n  status: 'fulfilled'\n  value: T\n}\ninterface Rejected {\n  status: 'rejected'\n  reason: unknown\n}\ninterface Pending<T> {\n  status: 'pending'\n\n  /**\n   * Resolve the promise with a value.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  resolve: (value: T) => void\n  /**\n   * Reject the promise with a reason.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  reject: (reason: unknown) => void\n}\n\nexport type FulfilledThenable<T> = Promise<T> & Fulfilled<T>\nexport type RejectedThenable<T> = Promise<T> & Rejected\nexport type PendingThenable<T> = Promise<T> & Pending<T>\n\nexport type Thenable<T> =\n  | FulfilledThenable<T>\n  | RejectedThenable<T>\n  | PendingThenable<T>\n\nexport function pendingThenable<T>(): PendingThenable<T> {\n  let resolve: Pending<T>['resolve']\n  let reject: Pending<T>['reject']\n  // this could use `Promise.withResolvers()` in the future\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  }) as PendingThenable<T>\n\n  thenable.status = 'pending'\n  thenable.catch(() => {\n    // prevent unhandled rejection errors\n  })\n\n  function finalize(data: Fulfilled<T> | Rejected) {\n    Object.assign(thenable, data)\n\n    // clear pending props props to avoid calling them twice\n    delete (thenable as Partial<PendingThenable<T>>).resolve\n    delete (thenable as Partial<PendingThenable<T>>).reject\n  }\n\n  thenable.resolve = (value) => {\n    finalize({\n      status: 'fulfilled',\n      value,\n    })\n\n    resolve(value)\n  }\n  thenable.reject = (reason) => {\n    finalize({\n      status: 'rejected',\n      reason,\n    })\n\n    reject(reason)\n  }\n\n  return thenable\n}\n","import type {\n  DefaultError,\n  Enabled,\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n  StaleTime,\n} from './types'\nimport type { Mutation } from './mutation'\nimport type { FetchOptions, Query } from './query'\n\n// TYPES\n\nexport interface QueryFilters<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: TQueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (\n    mutation: Mutation<TData, TError, TVariables, TContext>,\n  ) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis\n\nexport function noop(): void\nexport function noop(): undefined\nexport function noop() {}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function resolveStaleTime<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  staleTime: undefined | StaleTime<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): number | undefined {\n  return typeof staleTime === 'function' ? staleTime(query) : staleTime\n}\n\nexport function resolveEnabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  enabled: undefined | Enabled<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): boolean | undefined {\n  return typeof enabled === 'function' ? enabled(query) : enabled\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: Pick<QueryOptions<any, any, any, any>, 'queryKeyHashFn'>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aItems = array ? a : Object.keys(a)\n    const aSize = aItems.length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      if (\n        ((!array && aItems.includes(key)) || array) &&\n        a[key] === undefined &&\n        b[key] === undefined\n      ) {\n        copy[key] = undefined\n        equalItems++\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key])\n        if (copy[key] === a[key] && a[key] !== undefined) {\n          equalItems++\n        }\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects.\n */\nexport function shallowEqualObjects<T extends Record<string, any>>(\n  a: T,\n  b: T | undefined,\n): boolean {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (ctor === undefined) {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Handles Objects created by Object.create(<arbitrary prototype>)\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data) as TData\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== 'production') {\n      try {\n        return replaceEqualDeep(prevData, data)\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`,\n        )\n\n        // Prevent the replaceEqualDeep from being called again down below.\n        throw error\n      }\n    }\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n\nexport const skipToken = Symbol()\nexport type SkipToken = typeof skipToken\n\nexport function ensureQueryFn<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: {\n    queryFn?: QueryFunction<TQueryFnData, TQueryKey> | SkipToken\n    queryHash?: string\n  },\n  fetchOptions?: FetchOptions<TQueryFnData>,\n): QueryFunction<TQueryFnData, TQueryKey> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`,\n      )\n    }\n  }\n\n  // if we attempt to retry a fetch that was triggered from an initialPromise\n  // when we don't have a queryFn yet, we can't retry, so we just return the already rejected initialPromise\n  // if an observer has already mounted, we will be able to retry with that queryFn\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise!\n  }\n\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () =>\n      Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`))\n  }\n\n  return options.queryFn\n}\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n","function _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nexport { _assertClassBrand as default };","function _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nexport { _checkPrivateRedeclaration as default };","import assertClassBrand from \"./assertClassBrand.js\";\nfunction _classPrivateFieldGet2(s, a) {\n  return s.get(assertClassBrand(s, a));\n}\nexport { _classPrivateFieldGet2 as default };","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nexport { _classPrivateFieldInitSpec as default };","import assertClassBrand from \"./assertClassBrand.js\";\nfunction _classPrivateFieldSet2(s, a, r) {\n  return s.set(assertClassBrand(s, a), r), r;\n}\nexport { _classPrivateFieldSet2 as default };","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nfunction _classPrivateMethodInitSpec(e, a) {\n  checkPrivateRedeclaration(e, a), a.add(e);\n}\nexport { _classPrivateMethodInitSpec as default };"],"names":["focusManager","_focused","WeakMap","_cleanup","_setup","Subscribable","constructor","super","_classPrivateFieldInitSpec","_classPrivateFieldSet","this","onFocus","isServer","window","addEventListener","listener","removeEventListener","onSubscribe","_classPrivateFieldGet","setEventListener","onUnsubscribe","_classPrivateFieldGet2","hasListeners","call","setup","_classPrivateFieldGet3","focused","setFocused","isFocused","listeners","forEach","_globalThis$document","globalThis","document","visibilityState","defaultScheduler","cb","setTimeout","notifyManager","queue","transactions","notifyFn","callback","batchNotifyFn","scheduleFn","schedule","push","batch","result","flush","originalQueue","length","batchCalls","_len","arguments","args","Array","_key","setNotifyFunction","fn","setBatchNotifyFunction","setScheduler","createNotifyManager","onlineManager","_online","onOnline","onlineListener","offlineListener","setOnline","bind","online","isOnline","Query","_initialState","_revertState","_cache","_client","_retryer","_defaultOptions","_abortSignalConsumed","_Class_brand","WeakSet","Removable","config","_config$state","_classPrivateMethodInitSpec","defaultOptions","setOptions","options","observers","client","getQueryCache","queryKey","queryHash","data","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","Date","now","error","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","status","fetchStatus","getDefaultState","state","scheduleGc","meta","promise","_objectSpread","updateGcTime","gcTime","optionalRemove","remove","setData","newData","replaceData","_assertClassBrand","_dispatch","type","updatedAt","manual","setState","setStateOptions","cancel","_classPrivateFieldGet4","then","noop","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","resolveEnabled","enabled","isDisabled","getObserversCount","queryFn","skipToken","isStale","getCurrentResult","isStaleByTime","staleTime","undefined","timeUntilStale","_classPrivateFieldGet5","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","_classPrivateFieldGet6","shouldFetchOnReconnect","addObserver","includes","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","continueRetry","abortController","AbortController","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","context","fetchFn","ensureQueryFn","queryFnContext","persister","_context$fetchOptions2","behavior","onFetch","onError","_classPrivateFieldGet7","_classPrivateFieldGet8","_classPrivateFieldGet9","_classPrivateFieldGet10","isCancelledError","onSettled","createRetryer","initialPromise","abort","onSuccess","_classPrivateFieldGet11","_classPrivateFieldGet12","_classPrivateFieldGet13","_classPrivateFieldGet14","Error","concat","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","canRun","start","action","_action$meta","_action$dataUpdatedAt","fetchState","reducer","onQueryUpdate","canFetch","_gcTimeout","isValidTimeout","newGcTime","Math","max","Infinity","clearTimeout","defaultRetryDelay","min","CancelledError","value","continueFn","isRetryCancelled","isResolved","thenable","pendingThenable","canContinue","canStart","_config$onSuccess","_continueFn","reject","_config$onError","_continueFn2","pause","continueResolve","_config$onPause","_config$onContinue","run","promiseOrValue","_config$retry","_config$retryDelay","_config$onFail","delay","shouldRetry","sleep","cancelOptions","_config$abort","_continueFn3","Set","subscribe","add","delete","size","_resolve","_reject","finalize","assign","reason","functionalUpdate","updater","input","resolveStaleTime","matchQuery","filters","exact","predicate","stale","hashQueryKeyByOptions","partialMatchKey","matchMutation","mutation","mutationKey","hashKey","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","keys","sort","reduce","key","a","b","replaceEqualDeep","array","isPlainArray","aItems","aSize","bItems","bSize","copy","equalItems","i","shallowEqualObjects","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","getPrototypeOf","toString","timeout","prevData","structuralSharing","addToEnd","items","item","newItems","slice","addToStart","Symbol","QueryClientContext","React","useQueryClient","queryClient","QueryClientProvider","_ref","children","mount","unmount","jsx","Provider","e","t","n","has","TypeError","_checkPrivateRedeclaration","s","set","_classPrivateFieldSet2","r"],"sourceRoot":""}